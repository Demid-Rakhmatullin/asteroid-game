###### Управление

- Передвижение: Стрелочки и WASD  
- Выстрел: Пробел и ЛКМ  
- Выбор уровня: Клик по маркеру или названию  

###### Код  

Все сущности имеют Presenter, соответственно их список можно увидеть в папке Scripts/Presenters.

В качестве случайных параметров, которые генерируются для уровня, выбраны:  
- Количество очков, необходимое для победы
- Скорость спавна астероидов
- Наличие/отсутствие большого астероида

Разделение ответственности реализовывавлось по примеру из [документации](https://github.com/neuecc/UniRx) UniRX (паттерн MVP). Модели содержат свойства сущностей, а также их производные. Презентер отвечает за их начальное заполнение и связь с компонентами Unity на сцене. Эти визуальные компоненты (Button, Image, Text и т.д) рассматриваются как View с точки зрения данной реализации. Презентеры наследуются от MonoBehaviour, а модели нет.  

В моей реализации, помимо вышеперечисленных функций, в модели, по возможности, вынесена логика, не сильно связанная с MonoBehaviour (чтобы “разгрузить” презентеры). Модели напрямую не зависят от презентеров и друг от друга, зависимости между перезентерами сводились к минимуму. Для обмена данными между разными моделями и презентами используются UniRx messages (MessageBroker) и статический класс DataHub (для доступа к текущим состояниям объектов в любое время).  

Код сохранения состояний между запусками находится в папке Persistence. Список всех уровней грузится за раз из одного файла и далее кешируется. Если при обработке текущего фрейма были какие-то изменения в списке, то файл со списком целиком перезаписывается один раз в начале следующего фрейма.  

В целом, старался придерживаться такой концепции:  
- По возможности использовать реактивный подход  
- Искать баланс между усложнением архитектуры и расширяемостью
- Учитывать производительность получившегося решения  
- Обеспечивать некоторую самодокументированность

P.S. У меня нашелся очень старый мой проект тоже про астероиды (первый коммит), от которого взяты звуки и большая часть визуала.
